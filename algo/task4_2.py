from task4_code import Stack

'''
Задание 4.
Задача 5., 6.
Функция, проверяющая, является ли строка сбалансированной.
Временная сложность: O(n), пространственная: O(n).
'''

def isBalanced(string1: str) -> bool:
    if string1 == '':
        return None
    test_stack = Stack()
    match = {')':'(', ']':'[', '}':'{'}
    for i in string1:
        if i in '([{':
            test_stack.push(i)
        elif test_stack.size() == 0:
            return False
        elif i in ')]}' and test_stack.peek() == match[i]:
            test_stack.pop()
        else:
            return False
    return test_stack.size() == 0

'''
Задание 4.
Задача 7.
Функция, возвращающая минимальное значение в стеке.
Временная сложность: O(1), пространственная: O(1).
'''

def returnMin(stack: Stack) -> float:
    if stack.size() == 0:
        return None
    return stack.min_stack[-1]

'''
Задание 4.
Задача 8.
Функция, возвращающая среднее значение в стеке.
Временная сложность: O(1), пространственная: O(1).
'''

def returnAvg(stack: Stack) -> float:
    if stack.size() == 0:
        return None
    return stack.summ / stack.size()

'''
Задание 4.
Задача 9.
Функция, вычисляющая значение арифметического выражения, записанного в постфиксной форме.
Временная сложность: O(n), пространственная: O(n).
'''

def solve_postfix(expression: str) -> int:
    s1 = expression.split()[::-1]
    s2 = []

    while s1:
        element = s1.pop()

        if element.isdigit():
            s2.append(int(element))
        elif element in ('+', '*'):
            b = s2.pop()
            a = s2.pop()
            if element == '+':
                s2.append(a + b)
            else:
                s2.append(a * b)
        elif element == '=':
            return s2.pop()
        
'''
Рефлексия по решению задач задания 2.

9. Метод, который "переворачивает" связный список.
Решение совпадает с рекомендованным.

10. Проверка, имеются ли циклы внутри списка.
Использовала другое решение, с двумя "бегунками", один из которых на шаг впереди. Если они встречаются, то в списке есть цикл.

11. Сортировка списка.
Использовала сортировку пузырьком, как и рекомендовано.

12. Слияние списков.
Решение совпадает с первой части рекомендации: вначале оба списка сортируются, а затем из двух элементов выбирается меньший, который добавляется в результирующий список. 
Но мое решение подходит только для двух списков, а не произвольного количества.

13. Dummy.
Дамми реализовала отдельным классом, но он не является наследником основного класса узла, что упущение.

'''
